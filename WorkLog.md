# 记录一下机械臂制作过程，碰到的困难问题和挑战

## 电机

### 2024-05-10
在代码里测试了GPIO，ADC都没问题，但是SPI的NSS引脚PA4一直没有信号，我在代码中设置了每次SPI通信前将PA4置低电平开启MT6816，通信完置高电平关闭。
通过逻辑分析仪抓取发现NSS PA4引脚一直是低电平，代码中将PA4换成其他引脚PB8最为对照，然后测PB8引脚能抓到和代码吻合的电平变化，证明逻辑代码没问题。
最后将PA4引脚功能从SPI_NSS换成GPIO输出，然后问题就搞定了，从MT6816读取的数据很稳定，不飘，手按住电机转子稍微用力旋转，即使是弹性转动也能探测到数据变化，
松手数据也会回弹到之前的数据，证明电路设计也没有问题。接下来可以测试电机转动了。

#### 
[42步进电机接线](https://www.bilibili.com/read/cv5637376/)
- 判断哪两个引脚是一组线圈可以用万用表测电阻，如果电阻很小那么就是一组线圈
- 电流控制扭矩

### 2024-05-11
- 使用基本的8 step比较丝滑的电机正反转，至此所有的底层功能，外设都验证完成（DMA还没专门验证，不过应该没问题）。唯一一个例外是温敏电阻VCC搞错了，设置成了12v导致之前芯片引脚电压不对，所以温敏电阻adc读取的值无效，之后在新版本中修改。

- 研究怎么将底层硬件配置完全抽象出来，用c++ class封装一遍，保证上层软件和底层硬件配置解耦，方便以后灵活修改底层配置。

### 2024-05-12 - 15
- 将底层基本外设都剥离到单独的c文件，然后开始将c文件里的功能函数抽象出来提供给上层C++ class。比如adc.hpp 中的adc class 调用adc.c 的函数，此外，使用inline内联避免多次函数调用的额外开销。

### 2024-05-17 - 18
- 抽象出驱动层，mt67816, tb67h450等.

### 2024-05-19 
- 测试了简单的开环foc算法，控制电机丝滑转动

### 2024-05-20
- 优化和测试了Timer类，测试没有问题，可以用20khz为主任务，但是其他timer的中断处理必须尽量少消耗计算资源，不然主任务会受到干扰比如电机转动明显有顿挫一些。

- 研究了控制算法的原理

根据驱动硬件决定了对电机的控制只有三个方面：
1. 控制电机线圈两端是否通电以及方向，也就是AIN1，2 BIN1，2的电平
2. 通过vref控制电机驱动最大输出电流
3. 通过50us一次的控制算法任务中，控制每次电机走的步数，在foc中，可以将每个1.8度的整步都进行256细分，而控制电机转动指定细分步数，其实就是设置对应的两组线圈的电流值。也就是说，设置电流就能间接控制电机转动速度。

根据上面的分析，不难得出最核心的控制就是控制电流，具体来说就是控制vref的值，AIN1，2 BIN1，2只是配合设置方向。最本质的还是控制电流，这也是为什么pid算法的输出是电流值。
当然对TB67H450的控制并不能设置真实的电流值，而是设置最大电流输出，但是它内部实现了电流闭环，会将电流稳定在所需的最小值，所以我们最终只需要通过对最大电流输出的控制就能让电机丝滑转动。

TB67H450电机驱动IC的作用：
不仅能限制最大输出电流，还具有内部的闭环控制系统，确保实际电流稳定在所需的最小值。具体来说：

最大电流限制：保护电机不受过流损坏。
斩波恒流控制：通过快速开关电源调节电流，保持电流在设定范围内。
闭环电流控制：实时监测和调节电流，使其尽量接近所需的值。

参考资料：
https://github.com/peng-zhihui/Dummy-Robot/tree/main/2.Firmware/Ctrl-Step-Driver-STM32F1-fw
https://zhuanlan.zhihu.com/p/670162318

### 2024-05-21 - 22
- 调试uart dma，结果总是有重复发送等奇奇怪怪的问题。
结果发现是dma设置成了circular的，所以调用一次HAL_UART_Transmit_DMA就会连续不断的从给的地址复制内容然后发送，所以就算只调用一次也会不断重复发送。
解决办法： 
1. 将dma模式从circular改成normal
2. 开启uart global interrupt以便接收传输完成的callback。

- 尝试使用vofa+串口调试工具，也是上述问题导致显示不正常，解决之后显示正常了，firewater格式下，多个数据用逗号隔开，字符串末尾加"\n", 不需要"\r".
  鼠标放到y轴坐标区域滚动滚轮可以缩放y轴，不然就都是缩放x轴。 在y轴坐标区域按住左键上下移动拖动线条上下的位置

- 关于dma 用在tx:
1. Normal模式，手动调用HAL_UART_Transmit_DMA发送数据，等待完成的信号来到后可以再次调用这个函数发送
2. circular模式，调用一次HAL_UART_Transmit_DMA之后会不间断的连续发送，如果不及时对缓冲区进行清空或覆盖，就会导致重复发送
   可以尝试使用TxHalfCpltCallback信号，两倍长度的缓冲区，一次完整数据只占一般的缓冲区，这样TxHalfCpltCallback信号过来就说明
   一次数据已经发送完毕，可以用两个半个缓冲区交替传入数据。

### 2024-05-23 - 27
- 发现开源的电机控制算法还是有一些不懂，把XDrive项目下载下来先研究研究再接着写
- 研究了XDrive代码，基本明白代码流程和控制算法。控制算法基本上就是有电流，速度和位置三个追踪器，这三个追踪器会在新任务开始的时候同步一次真实的位置和速度值，
  然后根据设置的加速度将目标分解到每一个tick，这样能使电机运转的丝滑减少抖动。
  但是这三个追踪器在同步一次真实位置和速度值之后就只根据这个最初的同步值进行每个下一步的软目标的预测，直到新任务开启或者预测值达到硬目标值。也就是说它和控制算法pid和dec之间并没有再同步过真实值。
  有点奇怪，猜测在控制算法pid和dec里面，每个控制循环开始都会让电机走256细分，然而由于周期是50us，实际上电机在这么短的时间内无法走这么多位置，也就是说电机最终会是一个动态平衡的位置。

- 还有就是校准，在校准的20khz中断处理函数中，先会正反转分别测位置，然后对应到每个1.8度的步进角，在主循环的非中断循环中对每两个步进角的每个细分都进行线性映射，也就是说将14位16384个磁位置编码成对应的细分位置，以达到精确的控制。
  校准完的每个位置值一共16kb，会存在flash的指定位置，方便断电后任然存在，不用每次上电都重新校准。
### 2024-05-28
- 封装了stockpile对flash的读写，完善了motor和encoder类。

### 2024-05-28 - 06-01
- 改写了calibrator，将c封装成c++，并且测试了校准没有问题。

- 测试了电机在不同电流和不同步数的情况
1. 单次走256细分，0.45度， 2000，1000，500，200ma的情况：
  - 电流越大，电机移动的越快
  - 电流越大，电机抖动越明显，离预期值偏差越大

2. 连续走16细分，每个周期移动16细分，也就是细分位置每周期加16.
  - 只有大电流才能持续转动，小电流无法驱动连续转动，2000， 1500， 1000ma都能转，但是500ma转一点点就停住了。

3. 在每次连续固定增加细分数的情况下，每次走16细分能正常转动，32或64这种级别就不能转了。
   但是如果让速度渐变，也就是细分步数从1加速到128甚至256，都能如期转动，也就是说速度是可以加速到128甚至256的，也就是50和100r/s，
     但是加速度不能太快，测试了每两个周期细分步数自增1（T0 p = 0, T2 p += 1, T4 p+=1 ... T256 p+=1 => p = 128.) 可以如期逐渐加速到预期。
     256测试的每5个周期自增1， 也可以加速到预期。
  结论是，单次走256细分没问题，但是直接连续256细分走动就不行，但是以一定加速度加速到256细分是没问题的。猜测是惯性的原因，如上面第一点所说，电流越大抖动越明显，离预期值偏差越大，也就是说如果一上来就每周期走256细分会因为误差大电机无法连续转动，但是如果逐渐加速，每两次之间误差比较小，可以让电机连续转动

4. 在高速转动的情况下，扭矩小，转太快每次还没有达到最大扭矩电流就转下一次了，所以稍微给点阻力就会停转，步进电机适合低转速高扭矩场景。

PS: gpt的总结
测试结果分析
单次走256细分，电流越大，电机移动越快，抖动越明显：

这说明在大电流下，步进电机能产生更大的转矩，导致快速响应。但同时，由于惯性和电流过大引起的磁场变化剧烈，导致抖动增大。
大电流下，误差增大，说明电机可能因为过快的步进导致位置误差积累，从而引起抖动和不准确。
连续走16细分，小电流无法驱动连续转动：

小电流提供的转矩不足以克服电机的静摩擦力和动摩擦力，因此无法连续转动。
大电流能连续转动，说明有足够的转矩来维持运动。
速度渐变情况下，逐渐加速到高细分步数能正常转动：

逐渐加速能有效减少惯性带来的影响，使电机能够平稳过渡到高速步进。
突然的高细分步数（如连续256细分）会导致电机无法及时响应，导致失步或无法连续转动。
总结
电流大小影响转矩和稳定性：大电流提供更大转矩但也带来更大的抖动和误差。
逐步加速优于突然高速步进：逐渐加速可以平稳过渡，减少误差积累和失步现象。
控制周期与细分步数匹配：电机在较小步数下能更稳定地运行，需要逐步提升细分步数以适应高速。

### 2024-06-02
- 改写了speed 和 position tracker 成c++，简化了motor_control 成controller类，便于测试速度和位置模式的控制代码，其他复杂的东西以后再慢慢加上

### 2024-06-03 - 06-05
- 简单加上了一个闲时中断的dma处理class，但是具体协议还没设计，准备设计一个uart和can通用的协议，并且可以扩展成更多

### 2024-06-06
- 跑了一下position和speed模式，都可以正常运作，使用vofa+抓取了曲线，position的曲线比较丝滑，speed的波动相对大一点，可能需要重新设计算法或者调pid。
- 还发现一个问题，就是电机位置稳定后，虽然可以在有负载的情况下任然保持指定速度或者位置，但是如果用手频繁的来回转动法兰，会有肉眼可见的抖动幅度，能达到15度左右，像是人为的频率和电机产生共振一样，初步估计pid某个值太大
- 如果设计了协议，那么发送协议就需要专门的程序代码，然而市面上能找到的串口工具都不支持实时调整pid并实时显示图像，可以用qt简单写一个。

### 2024-08-01
- 串口调试工具终于阶段性完成，并且适配了电机端代码用于和上位机通信。https://github.com/xiaochutan123l/OpenSerialDebugger/tree/main
- 进行了如下测试：
1. 测试speed模式下，不同kp ki kd，找不到明显更好的参数组合
2. 测试location模式下，不同kp ki kd kv，也找不到明显更好的参数组合
3. 到达目标位置后，用手能轻微晃动的问题调pidv参数看不到明显改善。
4. 测试了Control_PID_To_Electric函数里m_foc_location = m_est_location + Move_Divide_NUM， 这个256细分步数，尝试了用128，没有明显区别，速度还是有明显噪声，尤其是低速的时候，没法丝滑。尝试了64，电机无法进行高转速，估计是由于64细分步数无法支持高转速。

- speed 和location模式就测试到这里，接下来加上姿态模式，以及各种检测，堵转等，因为减速器已经到手。
- can通信任然没有测试，考虑线自己画一个can usb模块方便测试。

### 2024-08-03
- 加上了电流模式，停止模式，堵转和过载保护的代码
- 在50us的主周期里通过获取当前微秒数来查看50us函数执行时间，发现大于50us，最高超过100us，但是电机运行正常，很神奇
- 测试了改成100khz也就是100us的周期，除了校准过程慢了一倍，运行效果和50us一样，丝毫看不出来差别，很神奇，xdrive源码鲁棒性真强

### 2024-08-04
- move reconstructor 运行的并不如预期，或者说不运作。设置以指定速度运动到指定位置换成了SetVelocityLimit。
- 但是考虑到之后机械臂的性能，最终会需要一个指令同时设置位置和最大速度。

- 今天安装上了减速器，30：1的，其实50:1的也买了，但是怕高减速比会烧坏板子，所以先试试30的。
- 30比的最高速转速能接受，作为机械臂关节的话。
- 30 比的减速器，无负载情况下，30r/s电机转速电流大概0.65A， 50r/s转速下1A多点，手指背放到电机驱动IC上明显高于体温，但是没有到烫手的程度，但是如果持续高速转动有温服持续上升的趋势，考虑到机械臂限位一次不会超过一圈，如果没有大负载的话应该还好。
- 装上减速器之后长度大概一个手掌宽，比想象中的小一些。
- 设置30r/s 的时候，减速器肉眼可见的比预期的1r/s要慢一点。
- 趣事：减速器本体和法兰需要M4的两颗螺丝连接，但是厂家只配了M3的两颗用来固定连接法兰和电机本体。机智的问了一下GPT M4螺丝一般用在哪里，得知电脑设备上经常有使用，想起来之前有电脑散热器多余的零件，果然找到几个M4螺丝，完美拧上然后进行了测试。

- 截至到今天，陆陆续续已经研究了3个月，电机代码大体完成（中间应该有将近两个月时间花费在写OpenSerialDebugger软件上），还有CAN模块没有写代码以及测试，因为手头没有CAN转usb的硬件模块。其他的话就是指令的处理可以继续完善，还有soft eeprom部分没有写完。总之到今天算是有了一个阶段性的成果。


- 发现实际运行速度大概是理论速度的1.6倍，估计是controller主函数超过50us的缘故，需要尝试精简主函数，看看实际速度是不是会更接近理论速度，或者开编译优化？
- 测试了开O3优化，一方面固件大小从43-44k降到了28k，另一方面实际速度确实差不多可以达到理论速度30r/s，但是50r/s还是不行，实际速度跟不上或者达不到速度追踪器里的理论值，导致实际位置和速度追踪器位置有大的偏差。
- 分析：抓取了实时速度，发现基本上1600000step/s基本上是能达到的最大值，也就是差不多30r/s应该是最大值，不然就会跟不上速度追踪器理论值，导致提早开始减速。(这可能是为什么稚晖君代码里也是设置的30r/s最大转速)

### 2024-08-05
- 电压加到24v，可以跑到最高速50r/s，看来电源是跑不到最高速的原因
- 测试了负载，负载直接加在减速器法兰附近，试了了2l油，和5l油负载，电流消耗没有大的变化，基本上空转500+ma，有负载600+ma左右，区别不大。最终还是得看末端负载情况。
- 到达目标位置后，静态电流30+ma，在90度位置加负载，电流50+ma，还是很小。

## 问题
### Cmake:
- Cmake 配置信息从最外层到最里层传递。